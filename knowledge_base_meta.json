{
  "project": {
    "name": "pplx-spa-assets-knowledge",
    "version": "1.0.0",
    "description": "Perplexity AI SPA static assets analyzer, knowledge base generator, and OpenAPI/AsyncAPI/JSON Schema specification builder",
    "repository": "https://github.com/pv-udpv/pplx-spa-assets-knowledge",
    "author": "pv-udpv",
    "license": "MIT",
    "keywords": [
      "perplexity",
      "spa",
      "reverse-engineering",
      "openapi",
      "asyncapi",
      "json-schema",
      "mcp",
      "knowledge-base",
      "typescript",
      "ast-parser"
    ]
  },
  "stats": {
    "har_entries": 786,
    "js_modules_total": 752,
    "js_modules_app": 397,
    "js_modules_vendor": 322,
    "js_modules_internal": 33,
    "rest_endpoints": 404,
    "rest_categories": 53,
    "sse_endpoints": 14,
    "websocket_channels": 8,
    "source_size_original": "3.37 MB",
    "source_size_compressed": "1.2 MB",
    "compression_ratio": 2.81
  },
  "artifacts": {
    "specifications": [
      {
        "name": "perplexity_spa_full_spec.json",
        "description": "Complete SPA specification including all endpoints, types, WebSocket channels, and event streams",
        "size": "1.9 MB",
        "format": "JSON",
        "schema": "OpenAPI 3.1.0",
        "path": "./specs/perplexity_spa_full_spec.json",
        "usage": ["api-documentation", "testing", "client-generation"]
      },
      {
        "name": "perplexity_endpoints_spec.json",
        "description": "REST endpoints specification optimized for client library generation",
        "size": "37 KB",
        "format": "JSON",
        "schema": "OpenAPI 3.1.0",
        "path": "./specs/perplexity_endpoints_spec.json",
        "usage": ["client-generation", "api-testing"]
      },
      {
        "name": "api-v1.yaml",
        "description": "OpenAPI v3.1 specification in YAML format",
        "size": "~150 KB",
        "format": "YAML",
        "schema": "OpenAPI 3.1.0",
        "path": "./specs/openapi/api-v1.yaml",
        "usage": ["swagger-ui", "redoc", "openapi-generator"]
      },
      {
        "name": "events.yaml",
        "description": "AsyncAPI v3.0 specification for WebSocket and SSE events",
        "size": "~50 KB",
        "format": "YAML",
        "schema": "AsyncAPI 3.0.0",
        "path": "./specs/asyncapi/events.yaml",
        "usage": ["websocket-documentation", "event-driven-architecture"]
      },
      {
        "name": "perplexity_spa_full_spec.json.gz",
        "description": "Compressed full specification for efficient storage and transfer",
        "size": "~500 KB",
        "format": "Gzip",
        "path": "./specs/perplexity_spa_full_spec.json.gz",
        "usage": ["storage", "transfer"]
      }
    ],
    "raw_data": [
      {
        "name": "session.har",
        "description": "HTTP Archive with all captured network requests and responses",
        "format": "HAR 1.2",
        "location": "./captures/har/",
        "usage": ["network-analysis", "request-replay", "performance-testing"]
      },
      {
        "name": "websocket-messages.jsonl",
        "description": "Timestamped WebSocket messages with event types and payloads",
        "format": "JSONL",
        "location": "./captures/websocket/",
        "usage": ["real-time-events", "protocol-analysis"]
      },
      {
        "name": "perplexity_source_index.json",
        "description": "Comprehensive index of all analyzed source files with symbols and types",
        "size": "118 KB",
        "format": "JSON",
        "location": "./parsed/",
        "usage": ["code-navigation", "symbol-search", "type-lookup"]
      },
      {
        "name": "network-timings.json",
        "description": "Performance metrics for network requests (DNS, TCP, SSL, TTFB, download)",
        "format": "JSON",
        "location": "./captures/timings/",
        "usage": ["performance-analysis", "bottleneck-detection"]
      },
      {
        "name": "bundles",
        "description": "Downloaded SPA JavaScript bundles with source maps",
        "format": "JavaScript, SourceMaps",
        "location": "./assets-cache/",
        "usage": ["debugging", "source-analysis"]
      }
    ],
    "tools": [
      {
        "name": "automcp.config.json",
        "description": "automcp configuration for MCP tool registration",
        "size": "~10 KB",
        "format": "JSON",
        "path": "./automcp.config.json",
        "usage": ["mcp-integration", "tool-configuration"]
      },
      {
        "name": "mcp-server",
        "description": "Generated Model Context Protocol server with API tools",
        "size": "~15 KB",
        "format": "TypeScript",
        "path": "./mcp/pplx-api/",
        "usage": ["claude-desktop", "cline", "mcp-clients"]
      },
      {
        "name": "knowledge-base.json",
        "description": "Structured knowledge entries with entities and relationships",
        "size": "~200 KB",
        "format": "JSON",
        "path": "./kb/knowledge-base.json",
        "usage": ["graphrag", "semantic-search", "knowledge-graphs"]
      }
    ]
  },
  "endpoint_categories": [
    "authentication",
    "search",
    "threads",
    "user",
    "collections",
    "spaces",
    "sources",
    "suggestions",
    "billing",
    "subscriptions",
    "organizations",
    "teams",
    "invitations",
    "notifications",
    "settings",
    "preferences",
    "analytics",
    "feedback",
    "reports",
    "exports",
    "imports",
    "integrations",
    "webhooks",
    "api-keys",
    "oauth",
    "permissions",
    "roles",
    "audit-logs",
    "metrics",
    "health",
    "status",
    "version",
    "capabilities",
    "discovery",
    "metadata",
    "schema",
    "documentation",
    "templates",
    "presets",
    "shortcuts",
    "bookmarks",
    "history",
    "recent",
    "trending",
    "recommended",
    "popular",
    "featured",
    "related",
    "similar",
    "follow",
    "share",
    "collaborate",
    "comments",
    "reactions"
  ],
  "usage": {
    "cli_commands": [
      {
        "command": "browser",
        "description": "Launch browser automation with Chrome DevTools Protocol",
        "syntax": "node dist/cli.js browser [options]",
        "options": [
          "-p, --preset <preset>: Capture preset (minimal, apiReversing, full, development)",
          "-u, --url <url>: Target URL",
          "-c, --chrome-port <port>: CDP port",
          "--headless: Run in headless mode",
          "-o, --output <dir>: Output directory"
        ],
        "examples": [
          "node dist/cli.js browser --preset apiReversing --url https://www.perplexity.ai"
        ]
      },
      {
        "command": "fetch",
        "description": "Download SPA assets from CDN with concurrent connections",
        "syntax": "npm run fetch -- [options]",
        "options": [
          "-s, --source <url>: Source CDN URL",
          "-o, --output <dir>: Cache directory",
          "-m, --manifest <path>: Manifest file",
          "-c, --concurrency <num>: Concurrent downloads",
          "-t, --timeout <ms>: Timeout"
        ],
        "examples": [
          "npm run fetch -- --source https://pplx-next-static-public.perplexity.ai --concurrency 5"
        ]
      },
      {
        "command": "analyze",
        "description": "Analyze local TypeScript/JavaScript files using AST parser",
        "syntax": "npm run analyze -- [options]",
        "options": [
          "-f, --file <path>: Single file path",
          "-d, --dir <path>: Directory path",
          "-p, --pattern <pattern>: File pattern",
          "-o, --output <dir>: Output directory",
          "-r, --recursive: Recursive scan"
        ],
        "examples": [
          "npm run analyze -- --dir ./src --recursive --pattern '*.{ts,tsx}'"
        ]
      },
      {
        "command": "parse",
        "description": "Parse fetched assets and extract types, endpoints, and symbols",
        "syntax": "npm run parse -- [options]",
        "options": [
          "-i, --input <dir>: Input directory",
          "-o, --output <dir>: Output directory"
        ],
        "examples": [
          "npm run parse -- --input ./assets-cache --output ./parsed"
        ]
      },
      {
        "command": "generate",
        "description": "Generate OpenAPI, AsyncAPI, and JSON Schema specifications",
        "syntax": "npm run generate -- [options]",
        "options": [
          "-t, --type <type>: Spec type (all, openapi, asyncapi, jsonschema)",
          "-i, --input <dir>: Input parsed data",
          "-o, --output <dir>: Output specs directory",
          "--title <title>: API title",
          "--version <version>: API version",
          "--base-url <url>: Base API URL"
        ],
        "examples": [
          "npm run generate -- --type all --title 'Perplexity AI API' --version 1.0.0"
        ]
      },
      {
        "command": "mcp",
        "description": "Generate Model Context Protocol server from OpenAPI spec",
        "syntax": "npm run mcp:generate -- [options]",
        "options": [
          "--spec <path>: OpenAPI spec path",
          "--output <dir>: Output directory",
          "--name <name>: Server name",
          "--version <version>: Server version",
          "--author <author>: Author name"
        ],
        "examples": [
          "npm run mcp:generate -- --spec ./specs/openapi/api-v1.yaml --name pplx-api"
        ]
      },
      {
        "command": "kb",
        "description": "Build structured knowledge base from parsed assets",
        "syntax": "npm run kb:build -- [options]",
        "options": [
          "-i, --input <dir>: Input parsed directory",
          "-o, --output <dir>: Output KB directory"
        ],
        "examples": [
          "npm run kb:build -- --input ./parsed --output ./kb"
        ]
      }
    ],
    "code_examples": [
      {
        "language": "python",
        "title": "List endpoints by category",
        "description": "Group and display API endpoints by category/tag",
        "code": "import json\nfrom collections import defaultdict\n\nwith open('perplexity_endpoints_spec.json', 'r') as f:\n    spec = json.load(f)\n\nendpoints_by_category = defaultdict(list)\n\nfor path, methods in spec['paths'].items():\n    for method, operation in methods.items():\n        tags = operation.get('tags', ['uncategorized'])\n        for tag in tags:\n            endpoints_by_category[tag].append({\n                'path': path,\n                'method': method.upper(),\n                'summary': operation.get('summary', '')\n            })\n\nfor category, endpoints in sorted(endpoints_by_category.items()):\n    print(f\"\\n{category.upper()} ({len(endpoints)} endpoints)\")\n    for ep in endpoints:\n        print(f\"  {ep['method']:6} {ep['path']:40} {ep['summary']}\")"
      },
      {
        "language": "python",
        "title": "Decode base64+gzip source code",
        "description": "Decode and decompress encoded source code from index",
        "code": "import json\nimport base64\nimport gzip\n\nwith open('perplexity_source_index.json', 'r') as f:\n    index = json.load(f)\n\ndef decode_source(encoded_content):\n    decoded = base64.b64decode(encoded_content)\n    decompressed = gzip.decompress(decoded)\n    return decompressed.decode('utf-8')\n\nfor module in index['modules']:\n    if 'SearchComponent' in str(module.get('symbols', [])):\n        print(f\"Found in: {module['path']}\")\n        if 'encodedContent' in module:\n            source = decode_source(module['encodedContent'])\n            print(source[:500])"
      },
      {
        "language": "typescript",
        "title": "List JavaScript modules sorted by size",
        "description": "Display top modules from source index",
        "code": "import { readFile } from 'fs/promises';\n\ninterface SourceIndex {\n  modules: Array<{\n    path: string;\n    size: number;\n    hash: string;\n    symbols: Array<{ name: string; kind: string }>;\n    types: Array<{ name: string; kind: string }>;\n  }>;\n}\n\nasync function listModules() {\n  const data = await readFile('perplexity_source_index.json', 'utf-8');\n  const index: SourceIndex = JSON.parse(data);\n\n  const sortedModules = index.modules\n    .sort((a, b) => b.size - a.size)\n    .slice(0, 10);\n\n  console.log('Top 10 Largest Modules:\\n');\n  for (const mod of sortedModules) {\n    const sizeKB = (mod.size / 1024).toFixed(1);\n    console.log(`${sizeKB.padStart(7)} KB  ${mod.path}`);\n  }\n}\n\nlistModules();"
      },
      {
        "language": "typescript",
        "title": "Access observed API calls from HAR",
        "description": "Analyze API calls from HAR capture",
        "code": "import { readFile } from 'fs/promises';\n\ninterface HAREntry {\n  request: { method: string; url: string };\n  response: { status: number };\n  timings: { send: number; wait: number; receive: number };\n}\n\nasync function analyzeAPICalls() {\n  const harData = await readFile('./captures/har/session.har', 'utf-8');\n  const har = JSON.parse(harData);\n\n  const apiCalls = har.log.entries.filter((e: HAREntry) => \n    e.request.url.includes('/api/')\n  );\n\n  const callsByEndpoint = new Map<string, HAREntry[]>();\n  \n  for (const call of apiCalls) {\n    const url = new URL(call.request.url);\n    const endpoint = `${call.request.method} ${url.pathname}`;\n    if (!callsByEndpoint.has(endpoint)) {\n      callsByEndpoint.set(endpoint, []);\n    }\n    callsByEndpoint.get(endpoint)!.push(call);\n  }\n\n  for (const [endpoint, calls] of callsByEndpoint) {\n    const avgLatency = calls.reduce((sum, c) => \n      sum + c.timings.wait + c.timings.receive, 0\n    ) / calls.length;\n    console.log(`${endpoint}: ${calls.length} calls, ${avgLatency.toFixed(1)}ms avg`);\n  }\n}\n\nanalyzeAPICalls();"
      },
      {
        "language": "typescript",
        "title": "Extract React hooks from parsed assets",
        "description": "Find and list React hooks from TypeScript analysis",
        "code": "import { ParsedAsset } from './src/types/index.js';\nimport { readFile } from 'fs/promises';\n\nasync function extractReactHooks() {\n  const parsedData = await readFile('./parsed/parsed-result.json', 'utf-8');\n  const assets: ParsedAsset[] = JSON.parse(parsedData);\n\n  const hooks: Array<{ name: string; file: string; type: string }> = [];\n\n  for (const asset of assets) {\n    for (const symbol of asset.chunks.flatMap(c => c.symbols)) {\n      if (symbol.kind === 'function' && symbol.name.startsWith('use')) {\n        hooks.push({\n          name: symbol.name,\n          file: symbol.location.file,\n          type: 'custom-hook'\n        });\n      }\n    }\n\n    for (const type of asset.extractedTypes) {\n      if (type.name.startsWith('Use') && type.name.endsWith('Hook')) {\n        hooks.push({\n          name: type.name,\n          file: asset.metadata.url,\n          type: 'hook-interface'\n        });\n      }\n    }\n  }\n\n  console.log(`Found ${hooks.length} React hooks`);\n  hooks.forEach(h => console.log(`  ${h.name} (${h.type})\\n    in ${h.file}`));\n}\n\nextractReactHooks();"
      }
    ]
  },
  "type_system": {
    "core_types": [
      {
        "name": "AssetMetadata",
        "description": "Metadata for fetched assets",
        "properties": ["url", "hash", "size", "contentType", "fetchedAt", "version"]
      },
      {
        "name": "ParsedAsset",
        "description": "Parsed asset with extracted code elements",
        "properties": ["metadata", "chunks", "extractedTypes", "apiEndpoints"]
      },
      {
        "name": "ExtractedType",
        "description": "TypeScript type, interface, class, or enum",
        "properties": ["name", "kind", "properties", "methods", "extends", "implements"]
      },
      {
        "name": "APIEndpoint",
        "description": "Discovered API endpoint",
        "properties": ["path", "method", "requestType", "responseType", "description"]
      },
      {
        "name": "Symbol",
        "description": "Code symbol with location",
        "properties": ["name", "kind", "exported", "location"]
      },
      {
        "name": "KnowledgeBaseEntry",
        "description": "Knowledge base entity or relationship",
        "properties": ["id", "type", "content", "metadata", "embeddings", "references"]
      }
    ]
  },
  "dependencies": {
    "production": {
      "@apidevtools/json-schema-ref-parser": "^11.7.2",
      "@asyncapi/parser": "^3.4.0",
      "@modelcontextprotocol/sdk": "^1.25.3",
      "@types/chrome-remote-interface": "^0.33.0",
      "chrome-remote-interface": "^0.33.3",
      "commander": "^12.1.0",
      "openapi-types": "^12.1.3",
      "ts-json-schema-generator": "^2.3.0",
      "ts-morph": "^22.0.0",
      "yaml": "^2.6.1",
      "zod": "^3.24.1",
      "zod-to-json-schema": "^3.24.1"
    },
    "development": {
      "@types/node": "^22.10.5",
      "@types/tampermonkey": "^5.0.3",
      "typescript": "^5.7.2",
      "vite": "^6.0.7",
      "vite-plugin-monkey": "^7.1.8"
    }
  },
  "performance": {
    "fetching": {
      "concurrency": "3-5 concurrent downloads (configurable)",
      "backoff": "Exponential: 1s, 2s, 4s, 8s, 16s",
      "throughput": "~10-50 files/sec (network dependent)",
      "memory": "O(file_size) per concurrent download"
    },
    "parsing": {
      "time": "~1-5s per 1MB bundle (ts-morph AST parsing)",
      "memory": "~200-300MB for 10MB bundle",
      "bottleneck": "ts-morph type inference"
    },
    "spec_generation": {
      "time": "~100ms for complete spec generation",
      "memory": "~50MB for 1000 types",
      "output": "Minimal (specs are text)"
    },
    "mcp_generation": {
      "time": "~50ms to generate full server",
      "output": "~15KB (complete server code)"
    }
  },
  "roadmap": {
    "phase_1": {
      "status": "complete",
      "title": "Asset Analysis and Spec Generation",
      "features": [
        "Asset fetching with retry logic",
        "TypeScript AST parsing",
        "OpenAPI v3.1 generation",
        "AsyncAPI v3.0 generation",
        "JSON Schema generation",
        "MCP server generation",
        "automcp configuration",
        "Knowledge base builder",
        "Browser automation with CDP"
      ]
    },
    "phase_2": {
      "status": "in_progress",
      "title": "GraphRAG Integration and Semantic Search",
      "target": "Q2 2025",
      "features": [
        "Vector embeddings for knowledge entries",
        "Graph database integration (Neo4j, TypeDB)",
        "Semantic search over codebase",
        "Relationship extraction and mapping",
        "Natural language query interface",
        "Entity disambiguation and linking",
        "Knowledge graph visualization"
      ]
    },
    "phase_3": {
      "status": "planned",
      "title": "CI/CD Automation and Change Detection",
      "target": "Q3 2025",
      "features": [
        "GitHub Actions workflow for automated monitoring",
        "Scheduled spec regeneration",
        "API change detection and diffing",
        "Breaking change alerts",
        "Automated versioning (semver)",
        "Changelog generation",
        "API governance integration",
        "Notification system"
      ]
    },
    "phase_4": {
      "status": "future",
      "title": "Advanced Features",
      "target": "Q4 2025+",
      "features": [
        "Visual API explorer web interface",
        "Interactive documentation portal",
        "GraphQL schema extraction",
        "gRPC/Protobuf support",
        "Multi-tenant API analysis",
        "Performance regression detection",
        "Security vulnerability scanning",
        "Mock server generation"
      ]
    }
  },
  "integration": {
    "related_projects": [
      {
        "name": "pplx-api-client",
        "description": "Unofficial Python/TypeScript clients for Perplexity AI API",
        "relationship": "Consumes generated OpenAPI specifications"
      },
      {
        "name": "pplx-mcp-server",
        "description": "Model Context Protocol server for Perplexity AI integration",
        "relationship": "Uses generated MCP server code"
      }
    ],
    "compatible_tools": [
      "Swagger UI",
      "Redoc",
      "openapi-generator",
      "Postman",
      "Insomnia",
      "Claude Desktop",
      "Cline",
      "automcp",
      "Neo4j",
      "TypeDB"
    ]
  },
  "metadata": {
    "generated_at": "2024-01-15T10:00:00Z",
    "schema_version": "1.0.0",
    "last_updated": "2024-01-15T10:00:00Z"
  }
}
